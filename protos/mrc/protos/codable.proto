/*
 * SPDX-FileCopyrightText: Copyright (c) 2021-2022,NVIDIA CORPORATION & AFFILIATES. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

import "google/protobuf/any.proto";

package mrc.codable.protos;

enum MemoryKind
{
    Host = 0;
    Pinned = 1;
    Device = 2;
    Managed = 3;
    None = 99;
}

enum MessageKind
{
    Default = 0;
    Eager = 1;
    Deferred = 2;
}

message RemoteMemoryDescriptor
{
    // the memory region must contain the remote buffer specified by the start at remote_address
    // and extending remote_bytes
    // if the remote buffer is part of a larger memory region, the remote_key should map that entire region
    // the remote registration cache will associated the remote_key with the entire memory region, thus for
    // for the pool/slab allocators, we should increase our cache hits and avoid the expensive key upacking

    uint64 instance_id = 1;
    uint64 address = 2;
    uint64 bytes = 3;
    uint64 memory_block_address = 4;
    uint64 memory_block_size = 5;
    bytes remote_key = 6;
    MemoryKind memory_kind = 7;
    bool should_cache = 8;
}

message PackedDescriptor
{
    uint32 buffer_id = 1;
    uint64 remote_address = 2;
    uint64 remote_bytes = 3;
    MemoryKind memory_kind = 4;
}

// Represents a chunk of data which is encoded into the message.
message EagerDescriptor
{
    // The bytes of the descriptor
    bytes data = 1;

    // The type of data. i.e. Host, Pinned, Shared, Device, Managed
    // Should be used to determine the destination of the bytes once deserialized
    MemoryKind memory_kind = 2;
}

message MetaDataDescriptor
{
    google.protobuf.Any meta_data = 1;
}

message Descriptor
{
    oneof desc
    {
        RemoteMemoryDescriptor remote_desc    = 1;
        PackedDescriptor       packed_desc    = 2;
        EagerDescriptor        eager_desc     = 3;
        MetaDataDescriptor     meta_data_desc = 4;
    }
}

message Object
{
    // int32 starting_descriptor_idx  = 1;
    int32 parent_object_idx = 1;
    uint64 type_index_hash = 2;
    repeated uint32 descriptor_idxs = 3;
    string debug_info = 4;
}

message EncodedObject
{
    repeated Descriptor descriptors = 1;
    repeated Object     objects     = 2;
    google.protobuf.Any meta_data   = 3;
}

message RemoteDescriptor
{
    uint64 instance_id = 1;
    uint64 object_id = 2;
    uint64 tokens = 3;
    EncodedObject encoded_object = 4;
}

// A deferred descriptor is a reference to a payload which is not encoded in the message. Instead, the payload is
// stored in a separate memory location and referenced by the payload_idx
message DeferredDescriptor
{
    uint64 payload_idx = 1; // The matching payload index for the deferred descriptor
}

// Represents a chunk of memory used to store data. Can either be eager (encoded into the message) or deferred
// (referenced by a non-owning payload)
message MemoryDescriptor
{
    oneof desc
    {
        EagerDescriptor eager_desc    = 1;
        DeferredDescriptor deferred_desc = 2;
    }
}

// Represents a local chunk of data for a DeferredDescriptor. This object is non-owning and only references existing
// data on the local machine. Converted to a RemotePayload before serialization
message LocalPayload
{
    // The uintptr address of the start point of the payload
    uint64 address = 1;

    // Number of bytes of the payload
    uint64 bytes = 2;

    // The type of data. i.e. Host, Pinned, Shared, Device, Managed
    MemoryKind memory_kind = 3;
}

// Represents a remote chunk of data for a DeferredDescriptor. This object is non-owning and only references existing
// data on a remote machine. Conversion to a LocalPayload is done after deserialization and performed by UCX
message RemotePayload
{
    // the memory region must contain the remote buffer specified by the start at remote_address
    // and extending remote_bytes
    // if the remote buffer is part of a larger memory region, the remote_key should map that entire region
    // the remote registration cache will associated the remote_key with the entire memory region, thus for
    // for the pool/slab allocators, we should increase our cache hits and avoid the expensive key upacking

    // The instance_id is used to identify the destination remote machine
    uint64 instance_id = 1;

    // The uintptr address of the start point of the payload
    uint64 address = 2;

    // Number of bytes of the payload
    uint64 bytes = 3;

    // The uintptr address of the memory block registered with UCX
    uint64 memory_block_address = 4;

    // The size of the memory block registered with UCX
    uint64 memory_block_size = 5;

    // The UCX hkey for the remote memory region
    bytes remote_key = 6;

    // The type of data. i.e. Host, Pinned, Shared, Device, Managed
    MemoryKind memory_kind = 7;

    bool should_cache = 8;
}

message SerializedInfo{
    repeated Object objects = 1;
    repeated MemoryDescriptor descriptors = 2;
    google.protobuf.Any meta_data   = 3;
}

// This object combines the object serialization info with the local payload information. Should only be used to
// represent an object which currently resides in memory
message LocalSerializedObject
{
    // Information about the object serialization. i.e. the number of internal objects, types of objects, and any
    // metadata
    SerializedInfo info = 1;

    // The payload stored on local machines associated with this object
    repeated LocalPayload payloads  = 2;
}

message RemoteSerializedObject
{
    // Destination of the remote object
    uint64 instance_id = 1;

    // Unique identifier for this object
    uint64 object_id = 2;

    // The number of "lifetime" tokens associated with this object. When the number of tokens reaches 0, the object
    // is deleted
    uint64 tokens = 3;

    // Information about the object serialization. i.e. the number of internal objects, types of objects, and any
    // metadata
    SerializedInfo info = 4;

    // The payload stored on remote machines associated with this object
    repeated RemotePayload payloads  = 5;
}

message Payload
{
    oneof message
    {
        EagerMessage eager_msg = 1;
        DeferredMessage deferred_msg = 2;
    }

    // Type of data. i.e. Host, Shared, Device
    MemoryKind memory_kind = 4;
}

message EagerMessage
{
    // Bytes of the message
    bytes data = 1;
}

message DeferredMessage
{
    // Address of the start point of the payload
    uint64 address = 1;

    // Number of bytes of the payload
    uint64 bytes = 2;

    // Address of mem registered with UCX
    uint64 memory_block_address = 3;

    // Size of the memory registered with UCX
    uint64 memory_block_size = 4;

    // The UCX hkey for the remote memory region
    bytes remote_key = 5;
}


message DescriptorObject
{
    // Destination of the remote object
    uint64 instance_id = 1;

    // Unique identifier of the DescriptorObject
    uint64 object_id = 2;

    // Payloads associated with this object
    repeated Payload payloads = 3;

    // The number of "lifetime" tokens associated with this object. When number of tokens reaches 0, the object is deleted

    // NOTE: This object is deprecated in the new implementation but kept for backwards compatibility.
    //       The new implementation relies on shared_ptr built-in reference counting
    uint64 tokens = 4;
}
